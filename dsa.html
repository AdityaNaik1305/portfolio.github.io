<!DOCTYPE html>
<html lang="en">
<head>
    <title>Elements Reference - Massively by HTML5 UP</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="assets/css/main.css">
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f9;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            text-align: center;
            color: #4CAF50;
        }
        ul {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        ul ul {
            margin-left: 20px; /* Indent nested lists */
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <!-- Main -->
    <div id="main">
        <!-- Post -->
        <section class="post">
            <header class="major">
                <h1>Design and Analysis of Algorithm</h1>
            </header>

            <!-- Introduction -->
            <h2>Introduction</h2>
            <p>This course explores the application of natural patterns and designs to solve real-world problems using data structures and algorithms. It highlights that algorithms are not just theoretical concepts but practical strategies used in everyday life. These algorithms help organize data, find the shortest path, and make decisions based on past information. The course connects the learning to real-time applications, demonstrating that algorithms are not just theoretical concepts but are rooted in our thinking and actions in the real world. By understanding the connection between these time-tested methods and their application in the modern world, students can better understand the world around them.</p>

            <!-- Real Time Application -->
            <h2>Real-Time Application</h2>
            <p>The Design and Analysis of Algorithms (DAA) applies to real-world problems by making tasks more efficient. For example, sorting algorithms help e-commerce sites organize products, while graph algorithms like Dijkstra’s are used in GPS to find the shortest routes. Dynamic programming optimizes scheduling, and greedy algorithms help minimize costs in network design. In short, algorithms are essential for improving speed and efficiency in various systems, from navigation to data management.</p>

            <!-- Algorithm Concepts -->
            <div class="container">
                <h3>What We've Studied Over the Course of 2 Years</h3>
                <ul>
                    <li>Data Structures and Algorithms:</li>
                    <ul>
                        <li>Data Structures:</li>
                        <ul>
                            <li>Arrays</li>
                            <li>Linked Lists</li>
                            <li>Stacks</li>
                            <li>Queues</li>
                            <li>Space and Time Complexities</li>
                        </ul>
                        <li>Trees and Graphs:</li>
                        <ul>
                            <li>Trees</li>
                            <li>AVL</li>
                            <li>BST</li>
                            <li>Red-Black Trees</li>
                            <li>2-3 Trees</li>
                            <li>Heaps</li>
                            <li>Tries</li>
                            <li>DFS</li>
                            <li>BFS</li>
                        </ul>
                        <li>Hashing and Hash Functions</li>
                        <li>Sorting:</li>
                        <ul>
                            <li>Bubble Sort</li>
                            <li>Selection Sort</li>
                            <li>Insertion Sort</li>
                            <li>Merge Sort</li>
                            <li>Quick Sort</li>
                            <li>Heap Sort</li>
                        </ul>
                        <li>Substring Search Algorithms:</li>
                        <ul>
                            <li>Brute-force Method</li>
                            <li>Boyer-Moore Algorithm</li>
                            <li>Knuth-Morris-Pratt Algorithm</li>
                            <li>Rabin-Karp Algorithm</li>
                        </ul>
                        <li>Graph Algorithms:</li>
                        <ul>
                            <li>Union-Find Data Structure</li>
                            <li>Shortest Path Algorithms</li>
                            <li>Minimum Spanning Tree Algorithms</li>
                        </ul>
                    </ul>
                </ul>
            </div>

            <div class="container">
                <h1>Algorithm Concepts</h1>
                <h2>1. Algorithmic Problem-Solving Strategies</h2>
                <ul>
                    <li><strong>Recursion:</strong>  Break down problems into smaller subproblems that are of the same type, and solve them recursively. Examples include the Fibonacci sequence, Tower of Hanoi, and Tree Traversals.</li>
                    <li><strong>Backtracking:</strong> A trial-and-error approach where you incrementally build a solution, backtracking when a path is found to be invalid. Classic problems include the N-Queens problem, Sudoku solver, and Subset Sum problem.</li>
                    <li><strong>Brute Force:</strong>  A straightforward approach where all possible solutions are checked without any optimization. Example: Finding all pairs in an array that sum to a target value.</li>
                </ul>
                <h2>2. Efficiency in Algorithms</h2>
                <ul>
                    <li><strong>Time Complexity:</strong> Analyze the number of operations or steps an algorithm takes relative to the input size. Common notations include Big-O (for worst case), Big-Ω (for best case), and Big-Θ (for average case).</li>
                    <li><strong>Space Complexity:</strong>Evaluate the amount of memory an algorithm requires during its execution. This is especially important for handling large datasets or constrained environments.</li>
                    <li><strong>Optimization:</strong> Strive for algorithms that minimize both time and space complexity. Efficient algorithms are critical for handling larger datasets in real-world applications.</li>
                </ul>

                <h2>3. Essential Data Structures</h2>
                <ul>
                    <li><strong>Trees:</strong> Store hierarchical data in structures like Binary Search Trees (BST) and AVL Trees. These are crucial for efficient searching, insertion, and deletion operations.</li>
                    <li><strong>Graphs:</strong> Use nodes and edges to represent relationships and solve problems related to connectivity, paths, and cycles.</li>
                    <li><strong>Hash Tables:</strong> Store key-value pairs to allow for average constant-time lookups, insertions, and deletions.</li>
                    <li><strong>Tries:</strong> Specialized tree structures used for fast string search operations.</li>
                    <li><strong>Heaps:</strong> Efficiently implement priority queues with logarithmic time operations.</li>
                </ul>

                <h2>4. Graph Algorithms</h2>
                <ul>
                    <li><strong>Depth-First Search (DFS):</strong> Explore as deep as possible down one path before backtracking.</li>
                    <li><strong>Breadth-First Search (BFS):</strong> Explore all nodes at the current level before moving deeper.</li>
                    <li><strong>Shortest Path Algorithms:</strong></li>
                    <ul>
                        <li>Dijkstra’s Algorithm</li>
                        <li>Bellman-Ford Algorithm</li>
                        <li>Floyd-Warshall Algorithm</li>
                    </ul>
                    <li><strong>Minimum Spanning Tree (MST):</strong> Connect all nodes in a graph with the least total weight.</li>
                </ul>

                <h2>5. Sorting and Searching</h2>
                <ul>
                    <li><strong>Sorting Algorithms:</strong></li>
                    <ul>
                        <li>Merge Sort</li>
                        <li>Quick Sort</li>
                        <li>Heap Sort</li>
                    </ul>
                    <li><strong>String Searching Algorithms:</strong></li>
                    <ul>
                        <li>Brute Force String Search</li>
                        <li>Booyer Moore String Match</li>
                        <li>Rabin Karp</li>
                        <li>Knuth-Morris-Pratt search</li>
                    </ul>
                </ul>
            </div>
        </section>
    </div>
</body>
</html>
